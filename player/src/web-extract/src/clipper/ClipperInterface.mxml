<?xml version="1.0" encoding="utf-8"?>
<s:Group xmlns:fx="http://ns.adobe.com/mxml/2009" 
		 xmlns:s="library://ns.adobe.com/flex/spark" 
		 xmlns:mx="library://ns.adobe.com/flex/mx" 
		 creationComplete="application1_applicationCompleteHandler(event)" 
 		 xmlns:media="org.osmf.media.*" styleName="btn" 
		 width="750" height="520" 
		 >
	<fx:Script>
		<![CDATA[
			import com.adobe.serialization.json.JSONDecoder;
			
			import mx.collections.ArrayCollection;
			import mx.collections.ArrayList;
			import mx.controls.Alert;
			import mx.core.UIComponent;
			import mx.events.CalendarLayoutChangeEvent;
			import mx.events.CloseEvent;
			import mx.events.DragEvent;
			import mx.events.FlexEvent;
			import mx.events.ToolTipEvent;
			
			import org.osmf.elements.AudioElement;
			import org.osmf.events.BufferEvent;
			import org.osmf.events.MediaElementEvent;
			import org.osmf.events.MediaErrorEvent;
			import org.osmf.events.MediaPlayerCapabilityChangeEvent;
			import org.osmf.events.PlayEvent;
			import org.osmf.events.TimeEvent;
			import org.osmf.media.URLResource;
			import org.osmf.traits.PlayState;
			
			import spark.components.mediaClasses.DynamicStreamingVideoItem;
			import spark.components.mediaClasses.DynamicStreamingVideoSource;
			import spark.events.IndexChangeEvent;
			import spark.events.TrackBaseEvent;
			import spark.primitives.Rect;
			import spark.skins.spark.ButtonSkin;
			
			/**
			 * On start up, collect the latest config file, then trigger update of service information.
			 */
			protected function application1_applicationCompleteHandler(event:FlexEvent):void
			{
				var configFile:String = "config.xml";
				var ur:URLRequest = new URLRequest(configFile);
				configLoader = new URLLoader();
				configLoader.addEventListener(IOErrorEvent.IO_ERROR,handleError);
				configLoader.addEventListener(SecurityErrorEvent.SECURITY_ERROR,handleError);
				configLoader.addEventListener(Event.COMPLETE,processConfigFileReceipt);
				
				try {
					configLoader.load(ur);
				} catch(e:Error) {
					handleError(e);
				}
			}
			/**
			 * Catch all error notification function.
			 */
			protected function handleError(e:*):void {
				var a:Alert
				var notification:String = "Sorry, we have encountered a problem communicating with the server. " +
					"Your work may not have been saved. Please check your connection and refresh the page to try again.\n" +
					"For debug purposes, the error was:\n";
				var ev:Event = e as Event;
				var er:Error = e as Error;
				if(ev) notification += ev.toString();
				else if(er) notification += er.getStackTrace();
				else notification += e.toString();
				Alert.show(notification,"Notification");
			}
			/**
			 * Generic workhorse loader, reused by changing .complete listener.
			 */
			protected var configLoader:URLLoader;
			/**
			 * Storage reference for received configs.
			 */
			protected var receivedConfigs:XML;
			/**
			 * Utility shortcut; JSON feed of services
			 */
			public function get serviceListingUrl():String {
				onlyIfConfigs();
				return receivedConfigs.serviceUrl[0].toString()+receivedConfigs.serviceService[0].toString();
			} 
			/**
			 * Utility shortcut; JSON feed of files as per request
			 */
			public function get fileListingUrl():String {
				onlyIfConfigs();
				var s:String = receivedConfigs.serviceUrl[0].toString()+receivedConfigs.fileService[0].toString();
				return s;
			} 
			/**
			 * Utility shortcut; download file service
			 */
			public function get downloadServiceUrl():String {
				onlyIfConfigs();
				var s:String = receivedConfigs.serviceUrl[0].toString()+receivedConfigs.downloadService[0].toString();
				return s;
			} 
			/**
			 * Utility shortcut; audio file location
			 */
			public function get audioFileUrl():String {
				onlyIfConfigs();
				var s:String = receivedConfigs.audioFile[0].toString();
				return s;
			} 
			/**
			 * Utility shortcut; file format
			 */
			public function get playFormat():String {
				onlyIfConfigs();
				var s:String = receivedConfigs.playFormat[0].toString();
				return s;
			}
			/**
			 * On first receipt of config file, set all that needs to be set,
			 * then reset listeners and get the services.
			 */
			protected function processConfigFileReceipt(event:Event):void {
				// Set the config reference
				try {
					receivedConfigs = new XML(configLoader.data);
				} catch(e:Error) {
					handleError(e);
					return;
				}
				// Swap the listeners.
				configLoader.removeEventListener(Event.COMPLETE,processConfigFileReceipt);
				configLoader.addEventListener(Event.COMPLETE,processServiceList);
				// Set up filelist values
				today = new FileList(fileListingUrl);
				today.addEventListener(SecurityErrorEvent.SECURITY_ERROR,handleError);
				today.addEventListener(IOErrorEvent.IO_ERROR,handleError);
				today.addEventListener(ErrorEvent.ERROR,handleError);
				today.addEventListener(Event.COMPLETE,processTodaysFiles);
				
				
				// Now call to update the service list.
				try {
					var s:String = serviceListingUrl;
					var ur:URLRequest = new URLRequest(s); 
					configLoader.load(ur);
				} catch(e:Error) {
					handleError(e);	
				}
			}
			/**
			 * For second, it should be a list of services.
			 * Assume it is a JSON file list and process accordingly.
			 */
			protected function processServiceList(event:Event):void {	
				// Change state for display
				currentState = "servicesLoaded";
				try {
					var v:Vector.<ServiceItem> = new Vector.<ServiceItem>;
					var o:Object = new JSONDecoder(configLoader.data).getValue();
					var a:Array = o.services;
					for(var i:int=0;i<a.length;i++) {
						var si:ServiceItem = new ServiceItem(a[i]);
						v.push(si);
						a[i] = si;
					}
					// Update references
					serviceSelector.dataProvider = new ArrayCollection(a);
					selectedService = a[0];
					// Finally, request file listing
				} catch(e:Error) {
					handleError(e);
				}
			}
			/**
			 * Maintain multiple filelists to give up to 24 hours from any file
			 */
			protected var today:FileList;
			protected function processTodaysFiles(event:Event=null):void {
				if(event) {
					if(today.service.id==selectedService.id) {
						selectedService.indexDate(today.date,today.results);
					}
				}
				availableFilesDisplay.dataProvider = new ArrayCollection(selectedService.filesFor(selectedDate));					
			}
			/**
			 * Utility shortcut to ensure called in correct order. Throws an error if no configs found.
			 */
			protected function onlyIfConfigs():void {
				if(receivedConfigs==null) var e:Error = new Error("Config file is not set.");
			}
			/**
			 * Utility shortcut to format date in to YYYY-MM-DD, if date is null, use a new Date(); (eg: default to today)
			 */
			protected function dateString(date:Date):String {
				if(!date) date = new Date();
				var y:String = pad(date.fullYear,4);
				// Flash dates are zero indexed
				var m:String = pad(1+date.month,2);
				var d:String = pad(date.date,2);
				return [y,m,d].join("-");
			}
			/**
			 * Utility to pad an int with zeros
			 */
			protected function pad(n:int,num:uint):String {
				var s:String = n.toString();
				while(s.length<num) s = "0"+s;
				return s;
			}
			///////////////////////////////////////////////////////
			protected function updateFileListing(service:ServiceItem,date:Date):void {
				//				var yesterdayDate:Date = new Date();
				//				yesterdayDate.setTime(date.time);
				//				yesterdayDate.date--;
				//				yesterday.loadFor(service,yesterdayDate);
				
				var a:Array = service.filesFor(date);
				if(ServiceItem.dateKey(date)==ServiceItem.dateKey(new Date()) || a.length==0) {
					// If it is today, or no listing then always update the list
					today.loadFor(service,date);
				} else {
					processTodaysFiles();
				}
			}
			////////////////////////////
			// FILE LISTING BASED ON SERVICE
			////////////////////////////
			/**
			 * Radio service that file list should be displaying.
			 */
			[Bindable] public function get selectedService():ServiceItem {
				return _selectedService;
			}
			public function set selectedService(si:ServiceItem):void {
				_selectedService = si;
				setStartFile(null);
				setEndFile(null);
				selectedDate = new Date();
				invalidateFilelist();
			}
			private var _selectedService:ServiceItem;
			/**
			 * Date to display files for the currently selected service.
			 */
			[Bindable] public function get selectedDate():Date {
				return _selectedDate;
			}
			public function set selectedDate(d:Date):void {
				// Don't allow going into the future...
				if(d>new Date()) d = new Date();
				_selectedDate = d;
				invalidateFilelist();
			}
			private var _selectedDate:Date = new Date();
			/**
			 * Validate / invalidate file list
			 */ 
			protected function invalidateFilelist():void {
				_filelistInvalid = true;
//				if(audio.playing) {
//					hasAudio = false;
//					audio.stop();
//				}
				availableFilesDisplay.dataProvider = null;
				invalidateDisplayList();
			}
			private var _filelistInvalid:Boolean = false;
			protected function validateFilelist():void {
				_filelistInvalid = false;
				selectedServiceTitle = selectedService ? selectedService.title : "";
				updateFileListing(selectedService,selectedDate);
			}
			////////////////////////////
			// END FILE LISTING BASED ON SERVICE
			////////////////////////////
			/**
			 * Start file
			 */
			public function getStartFile():FileItem {
				return _startFile;
			}
			public function setStartFile(fi:FileItem):void {
				_startFile = fi;
				hasBothFiles = _endFile!=null && _startFile!=null;
				startTimeStamp = fi ? displayTime : 0;
				invalidateFileSelection();
			}
			private var _startFile:FileItem;
			[Bindable] protected var startTimeStamp:int = 0;
			protected function formatTimeStamp(i:int):String {
				var hours:Number = Math.floor(i/3600);
				i -= hours*3600;
				var minutes:Number = Math.floor(i/60);
				i -= minutes*60;
				var seconds:Number = Math.floor(i);
				return [FileList.pad(hours,2),FileList.pad(minutes,2),FileList.pad(seconds,2)].join(":");
			}
			/**
			 * End file
			 */
			public function getEndFile():FileItem {
				return _endFile;
			}
			public function setEndFile(fi:FileItem):void {
				_endFile = fi;
				hasBothFiles = _endFile!=null && _startFile!=null;
				endTimeStamp = fi ? displayTime : 0;
				invalidateFileSelection();
			}
			private var _endFile:FileItem;
			[Bindable] protected var endTimeStamp:int = 0;
			[Bindable] protected var hasBothFiles:Boolean = false;
			/**
			 * Validate / invalidate file list
			 */ 
			protected function invalidateFileSelection():void {
				_fileSelectionInvalid = true;
				invalidateDisplayList();
			}
			private var _fileSelectionInvalid:Boolean = false;
			protected function validateFileSelection():void {
				_fileSelectionInvalid = false;
				canDownload = getEndFile()!=null && getStartFile()!=null;
				
				var diff:int = 0;
				if(canDownload) {
					var t1:int = 0;
					var t2:int = 0;
					var add1:int = 0;
					var add2:int = 0;
					t1 = getStartFile().toStartDate().getTime()
					t2 = getEndFile().toStartDate().getTime()
					add1 = startTimeStamp*1000;
					add2 = endTimeStamp*1000;
					diff = Math.abs(t2+add2-t1-add1)/1000;
				}
				currentGap = diff;
				startFileLabel = getStartFile() ? getStartFile().displayTitle : "";
				endFileLabel = getEndFile() ? getEndFile().displayTitle : "";
			}
			[Bindable] private var startFileLabel:String;
			[Bindable] private var endFileLabel:String;
			[Bindable] private var currentGap:int;
			[Bindable] private var selectedServiceTitle:String;
			
			////////////////////////////
			// FILE SELECTION FOR DOWNLOAD
			////////////////////////////
			override protected function updateDisplayList(unscaledWidth:Number, unscaledHeight:Number):void {
				super.updateDisplayList(unscaledWidth,unscaledHeight);
				if(_filelistInvalid) validateFilelist();
				if(_fileSelectionInvalid) validateFileSelection();
			}
			
			protected function serviceSelector_changeHandler(event:IndexChangeEvent):void
			{
				selectedService = serviceSelector.selectedItem as ServiceItem; 
			}
			protected function dateChooser_changeHandler(event:CalendarLayoutChangeEvent):void
			{
				selectedDate = dateChooser.selectedDate;
			}
			/**
			 * Set dates that cannot be shown
			 */
			protected function dateChooser_creationCompleteHandler(event:FlexEvent):void
			{
				// Need to be able to track up to 186 days of programming.
				// Set to 187 to give a bit of leeway.
				var startLimit:Date = new Date();
				startLimit.date -= 187;
				
				var endLimit:Date = new Date();
				endLimit.date++;
				dateChooser.disabledRanges = [{rangeStart:endLimit},{rangeEnd:startLimit}];
			}
			
			protected function setStartButton_clickHandler(event:MouseEvent):void
			{
				if(!availableFilesDisplay.selectedItem) return;
				if(!dateSelectionValid(availableFilesDisplay.selectedItem,displayTime,getEndFile(),endTimeStamp)) {
					if(dateSelectionTooLong(availableFilesDisplay.selectedItem,displayTime,getEndFile(),endTimeStamp)) {
						Alert.show("The time period selected is greater than twenty-four hours. Click OK to clear your end time or Cancel to cancel.","Notification",
							Alert.OK|Alert.CANCEL,null,
							processSetStartConfirm);
						return;
					}
					Alert.show("This file is after your selected end time. Click OK to clear your end time or Cancel to cancel.","Notification",
						Alert.OK|Alert.CANCEL,null,
						processSetStartConfirm);
					return;
				}
				processSetStartConfirm();
			}
			protected function processSetStartConfirm(event:CloseEvent=null):void {
				if(event && event.detail==Alert.CANCEL) {
					return;
				}
				setStartFile(availableFilesDisplay.selectedItem);
				if(!dateSelectionValid(getStartFile(),startTimeStamp,getEndFile(),endTimeStamp)) setEndFile(null);
				trace("(SET START "+this.startTimeStamp+" "+ this.currentTime+" "+this.getStartFile().file);
			}
			
			protected function setEndButton_clickHandler(event:MouseEvent):void
			{
				if(!availableFilesDisplay.selectedItem) return;
				if(!dateSelectionValid(getStartFile(),startTimeStamp,availableFilesDisplay.selectedItem,displayTime)) {
					if(dateSelectionTooLong(getStartFile(),startTimeStamp,availableFilesDisplay.selectedItem,displayTime)) {
						Alert.show("The time period selected is greater than twenty-four hours. Click OK to clear your start time or Cancel to cancel.","Notification",
							Alert.OK|Alert.CANCEL,null,
							processSetEndConfirm);
						return;
					}
					Alert.show("This file is before your selected start time. Click OK to clear your end time or Cancel to cancel.","Notification",
						Alert.OK|Alert.CANCEL,null,
						processSetEndConfirm);
					return;
				}
				processSetEndConfirm();
			}
			protected function processSetEndConfirm(event:CloseEvent=null):void {
				if(event && event.detail==Alert.CANCEL) return;
				setEndFile(availableFilesDisplay.selectedItem);
				if(!dateSelectionValid(getStartFile(),startTimeStamp,getEndFile(),endTimeStamp)) setStartFile(null);
			}
			
			protected function dateSelectionValid(newStart:FileItem,newStartTimeStamp:int,newEnd:FileItem,newEndTimeStamp:int):Boolean {
				if(!newStart || !newEnd) return true;
				if(dateSelectionTooLong(newStart,newStartTimeStamp,newEnd,newEndTimeStamp)) return false;
				if(newStart==newEnd) return newStartTimeStamp<newEndTimeStamp;
				return newStart.toStartDate().getTime() < newEnd.toStartDate().getTime();
			}
			protected function dateSelectionTooLong(newStart:FileItem,newStartTimeStamp:int,newEnd:FileItem,newEndTimeStamp:int):Boolean {
				if(!newStart || !newEnd) return false;
				var t1:int = newStart.toStartDate().getTime();
				var t2:int = newEnd.toStartDate().getTime();
				var add1:int = newStartTimeStamp/1000;
				var add2:int = newEndTimeStamp/1000;
				var diff:int = Math.abs(t2+add2-t1-add1);
				var aFullDay:int = 24*60*60*1000;
				return diff>aFullDay;
			}
			protected function clearButton_clickHandler(event:MouseEvent):void
			{
				setStartFile(null);
				setEndFile(null);
			}
			
			protected function nextItem():FileItem {
				if(!selectedItem) return null;
				// Loop from beginning to n-1. If find a match, return the next item.
				for(var i:int=0;i<availableFilesDisplay.dataProvider.length-1;i++) {
					var test:FileItem = availableFilesDisplay.dataProvider.getItemAt(i) as FileItem;
					if(test && selectedItem.file==test.file) {
						availableFilesDisplay.selectedIndex = (i+1);
						return availableFilesDisplay.dataProvider.getItemAt(i+1) as FileItem;
					}
				}
				return null;				
			}
			[Bindable] protected var selectedItemTitle:String = "";
			[Bindable] protected var selectedItem:FileItem;
			[Bindable] protected var filePosition:int = 0;
			protected function availableFilesDisplay_changeHandler(event:IndexChangeEvent):void
			{
				dragging = true;
				var fi:FileItem = availableFilesDisplay.selectedItem as FileItem;
				if(fi) {
					setFileSelection(fi);
				} else {
					var s:String = availableFilesDisplay.selectedItem as String;
					trace("STRING "+s);
				}
				
				dragging = false;
			}
			protected function setFileSelection(fi:FileItem):void {
				selectedItem = fi;
				selectedItemTitle = fi ? fi.displayTitle : "";
				filePosition = 0;
				playFile(fi);
			}
			protected function showDSTTime(value:Number):Object {
				return toDST(selectedItem,value);
				//				var d:Date = selectedItem.toStartDate();
				//				d.time += value*1000;
				//				return d.toString();
			}
			protected function toDST(fi:FileItem,value:Number):String {
				var d:Date = fi.toStartDate();
				d.time += value*1000;
				return d.toString();
			}
			
			protected function playFile(fi:FileItem):void {
				playingFile = fi;
				var fileSource:String = audioFileUrl+restFragment(playFormat,selectedService.id,fi.toFileRequestDateKey(),fi.file);
				var audioElement:AudioElement = new AudioElement();
				audioElement.addEventListener(MediaElementEvent.METADATA_ADD,trace);
				audioElement.resource = new URLResource(fileSource);
				audio.media = audioElement; 
				if(ServiceItem.dateKey(fi.toLocalDate())!=ServiceItem.dateKey(selectedDate)) selectedDate = fi.toStartDate();
			}
			protected var playingFile:FileItem;
			protected var startFrom:int = 0;
			protected var stopAt:int = 0;
			protected function soundStart(event:Event):void {
				var s:Sound = event.target as Sound;
				s.play(startFrom);
			}
			protected function restFragment(...rest:Array):String {
				var s:String = rest.join("/");
				return s;
			}
			
			[Bindable] protected var playState:String;
			[Bindable] protected var bufferTime:Number;
			[Bindable] protected var displayTime:Number;
			[Bindable] protected var currentTime:Number;
			[Bindable] protected var duration:Number;
			[Bindable] protected var hasAudio:Boolean = false;
			[Bindable] protected var playing:Boolean = false;
			protected function audio_bufferTimeChangeHandler(event:BufferEvent):void
			{
				bufferTime = event.bufferTime;
			}
			
			protected function audio_playStateChangeHandler(event:PlayEvent):void
			{
				playState = event.playState;
				playing = playState==PlayState.PLAYING;
				switch(playState) {
					case PlayState.STOPPED :
						if(!dragging && hasAudio) {
							var fi:FileItem = nextItem();
							if(fi) {
								trace("LOADING NEXT ITEM");
								setFileSelection(fi);
							}
						}
						break;
				}
			}
			
			
			protected function audio_currentTimeChangeHandler(event:TimeEvent):void
			{
				processTimeChange();
			}
			
			
			protected function audio_durationChangeHandler(event:TimeEvent):void
			{
				processTimeChange();
			}
			
			protected function processTimeChange():void {
				if(isNaN(audio.duration*audio.currentTime)) return;
				currentTime = audio.currentTime;
				duration = audio.duration;
				if(!dragging) displayTime = currentTime;
				try {
					if(startFrom>0) {
						audio.seek(startFrom);
						trace("Successful seek to "+audio.currentTime+" "+startFrom);
						startFrom = 0;
					}
				} catch(e:Error) {
					trace("Cannot seek.");
				}
				if(stopAt && currentTime>=stopAt) {
					var playing:Boolean = playState==PlayState.PLAYING;
					if(playing) audio.pause();
					stopAt = 0;
				}
			}
			
			protected function audio_hasAudioChangeHandler(event:MediaPlayerCapabilityChangeEvent):void
			{
				hasAudio = event.enabled;
			}
			
			
			[Bindable] protected var dragging:Boolean = false;
			protected function position_thumbPressHandler(event:TrackBaseEvent):void
			{
				dragging = true;
				startFrom = stopAt = 0;
				audio.pause();
			}
			protected function position_thumbReleaseHandler(event:TrackBaseEvent):void
			{
				dragging = false;
				audio.seek(position.value);
				audio.play();
				displayTime = position.value;
			}
			
			
			protected function position_changeHandler(event:Event):void
			{
				dragging = false;
				audio.seek(position.value);
				audio.play();
				displayTime = position.value;
			}
			
			
			protected function muteButton_clickHandler(event:MouseEvent):void
			{
				muted = !muted;
			}
			[Bindable] protected var muted:Boolean = false;
			[Bindable] protected var volume:Number = 0.8;
			protected function volumeSlider_changeHandler(event:Event):void
			{
				volume = volumeSlider.value;
			}
			
			
			protected function playPause_clickHandler(event:MouseEvent):void
			{
				var playing:Boolean = playState==PlayState.PLAYING;
				if(playing) {
					audio.pause();
				} else {
					audio.play();
				}
				
			}
			
			private var fr:FileReference;
			[Bindable] protected var canDownload:Boolean = false;
			protected function doDownload_clickHandler(event:MouseEvent):void
			{
				// TODO Auto-generated method stub
				if(fr==null) {
					fr = new FileReference();
					fr.addEventListener(SecurityErrorEvent.SECURITY_ERROR,handleErrorDownload);
					fr.addEventListener(IOErrorEvent.IO_ERROR,handleErrorDownload);
					fr.addEventListener(Event.CANCEL,cleanUpDownload);
					fr.addEventListener(Event.COMPLETE,cleanUpDownload);
					fr.addEventListener(ProgressEvent.PROGRESS,updateDownload);
				}
				var uv:URLVariables = new URLVariables();
				uv.service = selectedService.id;
				uv.start = writeTimeStamp(getStartFile().toStartDate(),startTimeStamp);
				uv.end = writeTimeStamp(getEndFile().toStartDate(),endTimeStamp);
				uv.format = playFormat;
				
				var ur:URLRequest = new URLRequest(downloadServiceUrl);
				ur.method = URLRequestMethod.GET;
				ur.data = uv;
				
				var defaultFileName:String = [
					uv.service,
					writeLocalTimeStamp(getStartFile().toStartDate(),startTimeStamp),
					writeLocalTimeStamp(getEndFile().toStartDate(),endTimeStamp)
				].join("_")+"."+uv.format;
				
				try {
					downloadStatus = "Downloading "+defaultFileName;
					downloadInProgress = true;
					fr.download(ur,defaultFileName);
				} catch(e:Error) {
					handleErrorDownload(e);
				}
			}
			protected function cleanUpDownload(event:Event=null):void {
				downloadStatus = "";
				downloadInProgress = false;
			}
			protected function handleErrorDownload(e:*):void {
				cleanUpDownload(null);
				handleError(e);
			}
			protected function updateDownload(event:ProgressEvent):void {
				downloadStatus = "Downloaded "+formatBytes(event.bytesLoaded)+" of "+formatBytes(event.bytesTotal)+"."
			}
			protected function formatBytes(i:int):String {
				if(i<1024) return i+" B";
				i /= 1024;
				if(i<1024) return i+" KB";
				i /= 1024;
				if(i<1024) return i+" MB";
				i /= 1024;
				return i+" GB";
			}
			[Bindable] protected var downloadInProgress:Boolean = false;
			[Bindable] protected var downloadStatus:String = "";
			protected function writeTimeStamp(d:Date,i:int):String {
				d.time += i*1000;
				var a:Array = [
					FileList.pad(d.fullYearUTC,4)
					,FileList.pad(d.monthUTC+1,2)
					,FileList.pad(d.dateUTC,2)
					,FileList.pad(d.hoursUTC,2)
					,FileList.pad(d.minutesUTC,2)
					,FileList.pad(d.secondsUTC,2)
					,FileList.pad(d.millisecondsUTC/10,2)
				];
				return a.join("-");
			}
			protected function writeLocalTimeStamp(d:Date,i:int):String {
				d.time += i*1000;
				var a:Array = [
					FileList.pad(d.fullYear,4)
					,FileList.pad(d.month+1,2)
					,FileList.pad(d.date,2)
					,FileList.pad(d.hours,2)
					,FileList.pad(d.minutes,2)
					,FileList.pad(d.seconds,2)
					,FileList.pad(d.milliseconds/10,2)
				];
				if(d.timezoneOffset) return a.join("-")+"offset"+(d.timezoneOffset/60)+"hr";
				return a.join("-");
			}
			protected function audio_mediaErrorHandler(event:MediaErrorEvent):void
			{
				if(this.hasAudio) handleError(event);
			}
			
			
			protected function volumeSlider_mutedChangeHandler(event:FlexEvent):void
			{
				muted = volumeSlider.muted;
			}
			
			
			protected function position_mouseOverHandler(event:MouseEvent):void
			{
				position_mouseMoveHandler(event);
			}
			
			
			protected function position_mouseMoveHandler(event:MouseEvent):void
			{
				position.toolTip = null;
				if(dragging) return;
				var range:Number = position.maximum-position.minimum;
				var b:Rectangle = position.track.getBounds(position);
				var pos:Number = Math.min(position.track.width,Math.max(0,position.track.mouseX-b.x))/b.width;
				var d:Date = selectedItem.toStartDate();
				d.time += pos*range*1000;
				var s:String = [FileList.pad(d.hours,2),FileList.pad(d.minutes,2)].join(":");
				position.toolTip = s;
			}
			
			
			protected function position_mouseOutHandler(event:MouseEvent):void
			{
				position.toolTip = null;
			}
			
			
			
			
			protected function position_toolTipShowHandler(event:ToolTipEvent):void
			{
				var ui:UIComponent = event.toolTip as UIComponent;
				ui.setStyle('fontSize',12);
				ui.setStyle('backgroundColor',0);
				ui.setStyle('color',0xffffff);
			}
			
			
			protected function doTest_clickHandler(event:MouseEvent):void
			{
				dragging = true;
				audio.stop();
				if(playingFile && playingFile.file==getStartFile().file) {
					dragging = false;
					audio.seek(startTimeStamp);
					audio.play();
					stopAt = startTimeStamp+10; 
					displayTime = position.value;
					return;
				}
				startFrom = startTimeStamp;
				stopAt = startFrom+10; 
				playFile(getStartFile());
				dragging = false;
				trace("STARTING FROM START "+[startFrom, endTimeStamp, stopAt, getStartFile()]);
			}
			
			
			protected function doEndTest_clickHandler(event:MouseEvent):void
			{
				dragging = true;
				audio.stop();
				if(playingFile && playingFile.file==getEndFile().file) {
					dragging = false;
					audio.seek(Math.max(0,endTimeStamp-10));
					audio.play();
					stopAt = endTimeStamp;
					displayTime = position.value;
					return;
				}
				startFrom = Math.max(0,endTimeStamp-10);
				stopAt = endTimeStamp;
				playFile(getEndFile());
				dragging = false;
				trace("STARTING FROM END "+[startFrom, endTimeStamp, stopAt, getEndFile()]);
			}
			
			
			protected function doPreTest_clickHandler(event:MouseEvent):void
			{
				dragging = true;
				audio.stop();
				if(playingFile && playingFile.file==getStartFile().file) {
					dragging = false;
					audio.seek(Math.max(0,startTimeStamp-10));
					audio.play();
					stopAt = startTimeStamp; 
					displayTime = position.value;
					return;
				}
				startFrom = Math.max(0,startTimeStamp-10);
				stopAt = startTimeStamp; 
				playFile(getStartFile());
				dragging = false;
				trace("STARTING FROM START "+[startFrom, endTimeStamp, stopAt, getStartFile()]);
			}
			
		]]>
	</fx:Script>
	<s:states>
		<s:State name="loadingConfig" />
		<s:State name="servicesLoaded" />
	</s:states>
	<fx:Declarations>
		<!-- Place non-visual elements (e.g., services, value objects) here -->
		<media:MediaPlayer autoPlay="true" volume="{volume}" muted="{muted}" loop="false" id="audio"  
						   bufferTimeChange="audio_bufferTimeChangeHandler(event)"  
						   playStateChange="audio_playStateChangeHandler(event)"
						   currentTimeChange="audio_currentTimeChangeHandler(event)"
						   durationChange="audio_durationChangeHandler(event)"
						   hasAudioChange="audio_hasAudioChangeHandler(event)"
						   mediaError="audio_mediaErrorHandler(event)"
						   />
	</fx:Declarations>
	<fx:Style source="appStyles.css" />
	<s:BitmapImage source="@Embed('../assets/AudioFile Player Background.png')" />
	<s:HGroup width="100%" height="100%" paddingLeft="20" paddingRight="20" paddingTop="20" paddingBottom="20">
		<s:VGroup width="100%" height="100%" includeIn="servicesLoaded">
			<s:VGroup width="100%" visible="{hasAudio}" >
				<s:Label text="{selectedServiceTitle}: {showDSTTime(currentTime)}" fontWeight="bold" fontSize="16" color="#ffffff" />
				<s:HGroup width="100%" verticalAlign="middle" gap="1">
					<s:ToggleButton id="playPauseButton" left="0" bottom="0" styleName="btn" 
									skinClass="spark.skins.spark.mediaClasses.normal.PlayPauseButtonSkin"
									click="playPause_clickHandler(event)" selected="{playing}" 
									/>
					<s:VolumeBar id="volumeSlider" styleName="btn" 
								 width="50" snapInterval="0" minimum="0" value="{volume}" maximum="1"  
								 liveDragging="true" change="volumeSlider_changeHandler(event)"
								 skinClass="skins.VolumeBar" mutedChange="volumeSlider_mutedChangeHandler(event)"
								 />
					<s:ScrubBar id="position" styleName="btn" 
								width="100%" skinClass="skins.ScrubBar" 
								mouseOver="position_mouseOverHandler(event)" mouseMove="position_mouseMoveHandler(event)" mouseOut="position_mouseOutHandler(event)"
								value="{displayTime}" 
								minimum="0" maximum="{duration}" liveDragging="false" showDataTip="true" dataTipFormatFunction="showDSTTime" 
								thumbPress="position_thumbPressHandler(event)"
								thumbRelease="position_thumbReleaseHandler(event)"
								change="position_changeHandler(event)" toolTipShow="position_toolTipShowHandler(event)"
								/>	
				</s:HGroup>
			</s:VGroup>
			<!--
			Controls and selection
			-->
			<s:HGroup width="100%" height="100%">
				<!-- 
				Select service and date 
				-->
				<s:VGroup id="dateAndService">
					<s:ComboBox id="serviceSelector" styleName="btn" fontWeight="bold"
								labelField="title" width="100%" 
								selectedItem="{selectedService}"
								change="serviceSelector_changeHandler(event)"
								/>
					<mx:DateChooser id="dateChooser" styleName="btn" selectedDate="{selectedDate}" firstDayOfWeek="1"
									change="dateChooser_changeHandler(event)" headerStyleName="dcHead" 
									creationComplete="dateChooser_creationCompleteHandler(event)"
									/>
				</s:VGroup>
				<!-- 
				Available file list 
				-->
				<s:List id="availableFilesDisplay" styleName="btn" height="{dateAndService.height}" width="250" labelField="displayTitle" change="availableFilesDisplay_changeHandler(event)" />
				<!--
				File selection workflow
				-->
				<s:VGroup width="100%" height="{dateAndService.height}" >
					<s:Label text="{toDST(getStartFile(),startTimeStamp)}" fontWeight="bold" color="#ffffff" />
					<s:HGroup width="100%">
						<s:Button styleName="btn" fontWeight="bold" label="Set clip start" id="setStartButton" click="setStartButton_clickHandler(event)" enabled="{hasAudio}" width="60%" />
						<s:Button styleName="btn" id="doTest" label="Listen to start" enabled="{canDownload}" click="doTest_clickHandler(event)" width="40%" />
					</s:HGroup>
					<s:Label text="{toDST(getEndFile(),endTimeStamp)}" fontWeight="bold" color="#ffffff" />
					<s:HGroup width="100%">
						<s:Button styleName="btn" fontWeight="bold" label="Set clip end" id="setEndButton" click="setEndButton_clickHandler(event)" enabled="{hasAudio}" width="60%" />
						<s:Button styleName="btn" id="doEndTest" label="Listen to end" enabled="{canDownload}" click="doEndTest_clickHandler(event)" width="40%" />
					</s:HGroup>
					<s:Label text="Total duration: {formatTimeStamp(currentGap)}" visible="{hasBothFiles}" fontWeight="bold" color="#ffffff" />
					<s:Button styleName="btn" id="doDownload" label="Download clip" fontWeight="bold" height="30" fontSize="18" enabled="{canDownload &amp;&amp; !downloadInProgress}" click="doDownload_clickHandler(event)" width="100%" />
					<mx:Text width="100%" text="{downloadStatus}" color="#ffffff" />
				</s:VGroup>
			</s:HGroup>
		</s:VGroup>
	</s:HGroup>
</s:Group>
